// It's a web server that demos various exploits
// Copyright (C) 2015  Billie Thompson <billie@purplebooth.co.uk>
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option)
// any later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program.  If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"fmt"
	"log"
	"net/http"
	"io/ioutil"
	"os"
	"database/sql"
	_ "github.com/mattn/go-sqlite3"
)

const port = 8080

const htmlTemplate = `<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Exploitable</title>
</head>

<body>
  <pre>%s</pre>
</body>
</html>`

const httpContentTypeValue = "text/html; charset=utf-8"
const httpContentTypeHeader = "Content-Type"

func sqlInjectionHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("SQL Injection")

	os.Remove("./sqli.db")

	db, _ := sql.Open("sqlite3", "./sqli.db")
	defer db.Close()

	sqlStmt := `
	create table sqli (id integer not null primary key, name text, secretinfo text, password text);
	`
	_, _ = db.Exec(sqlStmt)

	tx, _ := db.Begin()
	stmt, _ := tx.Prepare("insert into sqli(id, name, secretinfo, password) values(?, ?, ?, ?)")

	defer stmt.Close()
	_, _ = stmt.Exec(1, "Alice", "My secret", "tomato")
	_, _ = stmt.Exec(2, "Billie", "Another secret", "space")
	_, _ = stmt.Exec(3, "Carol", "Yet another secret", "dino")
	tx.Commit()

	sql := fmt.Sprintf("SELECT id, name, secretinfo FROM sqli WHERE password = \"%s\"", r.URL.Query().Get("pass"))
	log.Println(sql)
	rows, _ := db.Query(sql)
	w.Header().Set(httpContentTypeHeader, "text/plain")

	defer rows.Close()
	for rows.Next() {
		var id int
		var name string
		var secretinfo string

		rows.Scan(&id, &name, &secretinfo)
		fmt.Fprintf(w, "* %d %s %s \n", id, name, secretinfo)
	}
}

func xssHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("XSS")

	fmt.Fprintf(w, htmlTemplate, r.URL.Query().Get("q"))
}

func rfiHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("RFI")

	resp, _ := http.Get(r.URL.Query().Get("url"))

	defer resp.Body.Close()
	contents, _ := ioutil.ReadAll(resp.Body)

	fmt.Fprintf(w, string(contents))
}

func directoryTraversalHandler(w http.ResponseWriter, r *http.Request) {
	log.Println("Directory Traversal")

	fi, _ := ioutil.ReadFile(r.URL.Query().Get("f"))

	fmt.Fprintf(w, string(fi))
}

func main() {
	listeningAddress := fmt.Sprintf(":%d", port)
	log.Println("Listening for connections on", listeningAddress)

	http.HandleFunc("/sqlinjection/", sqlInjectionHandler)
	http.HandleFunc("/xss/", xssHandler)
	http.HandleFunc("/rfi/", rfiHandler)
	http.HandleFunc("/dt/", directoryTraversalHandler)
	http.ListenAndServe(listeningAddress, nil)
}